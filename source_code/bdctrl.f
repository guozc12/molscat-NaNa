      SUBROUTINE BDCTRL(N, MXLAM, NHAM, Y1, Y2,
     1                  U, PSIMCH, SUMPSI, VL, IV,
     2                  EINT, CENT, P, NODEC, ERED,
     3                  EP2RU, CM2RU, RSCALE, EIGMIN, WAVE,
     4                  IMIN, IPRINT)
C  Copyright (C) 2020 J. M. Hutson & C. R. Le Sueur
C  Distributed under the GNU General Public License, version 3
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C  ---------------------------------------------------------------
C  ROUTINE TO PERFORM A BOUND-STATE PROPAGATION. ON EXIT,
C  EIGMIN CONTAINS THE SMALLEST EIGENVALUE OF THE MATCHING MATRIX.
C  Y1 CONTAINS THE MATCHING MATRIX FOR USE BY EVMTCH
C  ---------------------------------------------------------------
C  THIS VERSION ORIGINALLY BY JM Hutson, 1988.
C  MODIFIED BY AE Thornley JULY 94 TO ALLOW WAVEFUNCTION PROPAGATION
C  FOR LDMD PROPAGATOR (ONLY)
C  EXTENDED BY JM Hutson 2006 TO ALLOW HYBRID LDMD/AIRY (ENERGIES ONLY)
C  MODIFIED SEPT 2012 TO ELIMINATE 3RD PROPAGATION PART AND
C  USE THE NUMBER OF NEGATIVE EIGENVALUES OF THE MATCHING MATRIX
C
C  03-12-15 CR Le Sueur:
C  ALLOW MATCHING POINT TO DIFFER FROM CHANGEOVER POINT BETWEEN
C  PROPAGATORS
C  CODE FOR PROPAGATORS EXTENDED TO CODE LONG AND SHORT RANGE
C  SEPARATELY
C
C  DIMENSION STATEMENTS FOR ARGUMENT LIST
      DIMENSION U(N*N),Y1(N*N),Y2(N*N),PSIMCH(N),SUMPSI(N)
      DIMENSION P(MXLAM),VL(2),IV(2),EINT(N),CENT(N)
      LOGICAL WAVE

      DIMENSION KREC(2)
C
C  DYNAMIC MEMORY COMMON BLOCK
      COMMON /MEMORY/ MX,IXNEXT,NIPR,IDUMMY,X(1)
C
      DIMENSION STPSEG(3),CAYSEG(3),TOLSEG(3),DRSEG(3),IPRSEG(3),
     1          RBSEG(3),RESEG(3),NSTEPS(3),POWSEG(3)
      LOGICAL LFIRST
C
C  COMMON BLOCK FOR CONTROL OF USE OF PROPAGATION SCRATCH FILE
      LOGICAL IREAD,IWRITE
      COMMON /PRPSCR/ ESHIFT,ISCRU,IREAD,IWRITE
C
C  COMMON BLOCK FOR CONTROL OF PROPAGATION SEGMENTS
      COMMON /RADIAL/ RMNINT,RMXINT,RMID,RMATCH,DRS,DRL,STEPS,STEPL,
     1                POWRS,POWRL,TOLHIS,TOLHIL,CAYS,CAYL,unset,
     2                IPROPS,IPROPL,NSEG
C
C  COMMON BLOCK FOR INPUT/OUTPUT CHANNEL NUMBERS
      LOGICAL PSIFMT
      COMMON /IOCHAN/ IPSISC,IWAVSC,IPSI,NWVCOL,PSIFMT

      CHARACTER(2) NCOL
      CHARACTER(60) F2000
C
      NSQ=N*N

      IF (WAVE) THEN
        CALL WVOPEN(N)
        WRITE(NCOL,'(I2)') MIN(N,NWVCOL)
        NCOL=ADJUSTR(NCOL)
        F2000='(1P,E15.7,1X'//NCOL//'(E15.7E3:,1X),/(16X,'//
     1                        NCOL//'(E15.7E3:,1X)))'

        IF (IPRINT.GE.30) WRITE(6,50)
  50    FORMAT('  WRITING OUT WAVEFUNCTION AT EVERY STEP')
      ENDIF
C
      CALL BDPSET(IPRSEG,RBSEG,RESEG,DRSEG,
     1            STPSEG,TOLSEG,CAYSEG,POWSEG,ICHNGE)

      NODEC=0
      NODES=-1
C
      IF (IREAD .OR. IWRITE) REWIND ISCRU

      IF (WAVE) SUMPSI=0D0
      IWREC=1
      NTSTPS=0
C
C  NOW LOOP OVER THE SEGMENTS.
C
      DO 100 ISEG=1,NSEG
        NUSED=0
        IPROP=IPRSEG(ISEG)
        CAY=CAYSEG(ISEG)
        DRT=DRSEG(ISEG)
        STEP=STPSEG(ISEG)
        TOLHIT=TOLSEG(ISEG)
        RSTART=RBSEG(ISEG)
        RSTOP=RESEG(ISEG)
        POW=POWSEG(ISEG)

        IF (IREAD) THEN
          READ(ISCRU) RSTART,RSTOP,EFIRST,ISTART,NSTEP,DR
          ESHIFT=ERED-EFIRST
        ELSE
          ISTART=1
          IF (ISEG.EQ.1 .OR. ISEG.EQ.ICHNGE+1) ISTART=0

          CALL DRSET(RSTART,RSTOP,-10.D0,TOLHIT,0.D0,DRT,NSTEP,DR,
     1               unset,IPROP,POW)
          IF (IWRITE) WRITE(ISCRU) RSTART,RSTOP,ERED,ISTART,NSTEP,DR
        ENDIF
        DRSEG(ISEG)=DR
C
C  INITIALISE Y MATRIX (HERE CALLED Y2)
C
        IT1=IXNEXT  ! DIAG
        IT2=IT1+N   ! EVAL
        IT3=IT2+N   ! EVECS
        IXNEXT=IT3+NSQ
        CALL CHKSTR(NUSED)
        IF (ISTART.EQ.0)
     1    CALL YINIT(Y2,U,VL,IV,P,CENT,EINT,X(IT1),X(IT2),
     2               X(IT3),N,MXLAM,NHAM,
     3               ERED,RSTART,EP2RU,CM2RU,RSCALE,
     4               RSTART.LT.RSTOP,IPRINT)
        IXNEXT=IT1
C
C  SKIP CALL TO PROPAGATION ROUTINE IF SEGMENT HAS EXACTLY ZERO LENGTH
C
        IF (RSTART .EQ. RSTOP) THEN
          NODES=0
          IF (IPRINT.GE.8) WRITE(6,60) ISEG,RSTART
  60      FORMAT('  NO PROPAGATION NEEDED FOR SEGMENT',I2,' BECAUSE',
     1           ' RSTART = RSTOP =',F12.4)
          GOTO 125
        ENDIF

        IF (IPROP.EQ.5) THEN
C  JOHNSON'S LOG-DERIVATIVE PROPAGATOR
          IT1=IXNEXT   ! DIAG
          IXNEXT=IT1+N
          CALL CHKSTR(NUSED)
          CALL LDPROP(N,MXLAM,NHAM,
     1                Y2,U,VL,IV,EINT,CENT,P,X(IT1),
     2                RSTART,RSTOP,NSTEP,DR,NODES,
     3                ERED,EP2RU,CM2RU,RSCALE,IPRINT)
          IXNEXT=IT1
C
        ELSEIF (IPROP.EQ.6) THEN
C  MANOLOPOULOS' DIABATIC LOG-DERIVATIVE PROPAGATOR
          IT1=IXNEXT   ! Y14
          IT2=IT1+N    ! Y23
          IT3=IT2+N    ! DIAG
C  *** EXTRA STORAGE REQUIRED FOR WAVEFUNCTIONS
          IT4=IT3+N    ! W
          IT5=IT4+NSQ  ! W2
          IT6=IT5+NSQ  ! W3
          IF (WAVE) THEN
            IXNEXT=IT6+NSQ
          ELSE
            IXNEXT=IT4
          ENDIF
          CALL CHKSTR(NUSED)
          CALL MDPROP(N,MXLAM,NHAM,
     1                Y2,U,VL,IV,EINT,CENT,P,
     2                X(IT1),X(IT2),X(IT3),X(IT4),X(IT5),X(IT6),
     3                RSTART,RSTOP,NSTEP,DR,NODES,IWREC,WAVE,
     4                ERED,EP2RU,CM2RU,RSCALE,IPRINT)

          IXNEXT=IT1
C
        ELSEIF (IPROP.EQ.7) THEN
C  MANOLOPOULOS' QUASI-ADIABATIC LOG-DERIVATIVE PROPAGATOR
          IT1=IXNEXT  ! T
          IT2=IT1+NSQ ! Q
          IT3=IT2+NSQ ! W
          IT4=IT3+NSQ ! EIVAL
          IT5=IT4+N   ! Y1
          IT6=IT5+N   ! Y2
          IT7=IT6+N   ! Y3
          IT8=IT7+N   ! Y4
          IT9=IT8+N   ! DIAG
          IXNEXT=IT9+N
          CALL CHKSTR(NUSED)
          CALL MAPROP(N,NSQ,MXLAM,NHAM,
     1                Y2,X(IT1),U,VL,IV,EINT,CENT,P,
     2                X(IT2),X(IT3),X(IT4),X(IT5),X(IT6),X(IT7),X(IT8),
     3                X(IT9),
     4                RSTART,RSTOP,NSTEP,DR,NODES,
     5                ERED,EP2RU,CM2RU,RSCALE,IPRINT)
          IXNEXT=IT1
C
        ELSEIF (IPROP.EQ.8) THEN
C  MANOLOPOULOS+GRAY SYMPLECTIC PROPAGATOR
          IT1=IXNEXT
          IXNEXT=IT1+N
          CALL CHKSTR(NUSED)
          CALL MGPROP(N,MXLAM,NHAM,
     1                Y2,U,VL,IV,EINT,CENT,P,X(IT1),
     3                RSTART,RSTOP,NSTEP,DR,NODES,
     4                ERED,EP2RU,CM2RU,RSCALE,IPRINT)
          IXNEXT=IT1
C
        ELSEIF (IPROP.EQ.9) THEN
C  AIRY PROPAGATOR (LONG-RANGE ONLY)
            IT1=IXNEXT    ! W
            IT2=IT1+NSQ   ! Y1
            IT3=IT2+N     ! Y2
            IT4=IT3+N     ! Y3
            IT5=IT4+N     ! Y4
            IT6=IT5+N     ! VECNOW
            IT7=IT6+NSQ   ! VECNEW
            IT8=IT7+NSQ   ! EIGOLD
            IT9=IT8+N     ! EIGNOW
            IT10=IT9+N    ! HP
            IXNEXT=IT10+N
            CALL CHKSTR(NUSED)
            CALL AIPROP(N,MXLAM,NHAM,
     1                  Y2,X(IT1),U,VL,IV,EINT,CENT,P,
     2                  X(IT2),X(IT3),X(IT4),X(IT5),X(IT6),X(IT7),
     3                  X(IT8),X(IT9),X(IT10),
     4                  RSTART,RSTOP,NSTEP,DR,POW,TOLHIT,NODES,
     5                  ERED,EP2RU,CM2RU,RSCALE,IPRINT)
          IXNEXT=IT1
C
        ELSE
          WRITE(6,110) IPROP
  110     FORMAT(/'  *** ERROR IN BDCTRL. NO IMPLEMENTATION FOR ',
     1           'PROPAGATOR CODE =',I3)
          STOP
        ENDIF
C
C  ---------------------------------------------------------------
C  END OF PROPAGATION
C
        IF (IPRINT.GE.8) THEN
          IF (ISEG.EQ.1) WRITE(6,*)
          WRITE(6,120) RSTART,RSTOP,NSTEP,NODES
        ENDIF
  120   FORMAT('  LOG-DERIVATIVE MATRIX PROPAGATED FROM ',
     1         F12.4,'  TO ',F12.4,'  IN ',I6,'  STEPS.',
     2         I6,' NODES FOUND.')
C
  125   CONTINUE
        NODEC=NODEC+NODES
        NSTEPS(ISEG)=NSTEP
        IF (ISEG.EQ.ICHNGE) THEN
C  KREC IS USED TO SAVE THE VALUE OF IWREC FOR BOTH PARTS OF WAVEFUNCTION
C  BACK-SUBSTITUTION.
C  IWREC IS WHERE TO READ RAB MATRIX FROM (SO GOES FROM LARGE NUMBER BACK
C  TOWARDS 1 IN BOTH CALLS TO EFPROP).
          KREC(1)=IWREC
          DO I=1,NSQ
            Y1(I)=Y2(I) ! Y1 IS NOW THE END OF THE OUTWARDS PROPAGATION
          ENDDO
        ELSEIF (ISEG.EQ.NSEG) THEN
          KREC(2)=IWREC
        ENDIF
  100 CONTINUE
C  END OF LOOP OVER SEGMENTS
C

      IF (IPRINT.GE.15) CALL MATPRN(6,Y2,N,N,N,2,Y2,' LOGD MATRIX',1)
      NTSTPS=NTSTPS+NSTEP
C
      DO I=1,NSQ
        Y2(I)=-Y2(I)+Y1(I) ! MATCHING MATRIX IS DEFINED AS INWARD-OUTWARD
        Y1(I)=Y2(I)        ! EVMTCH NEEDS A COPY OF THE MATCHING MATRIX
      ENDDO
C
      IF (IPRINT.GE.12) CALL MATPRN(6,Y2,N,N,N,2,Y2,
     1                              ' MATCHING MATRIX',1)
C
C  DIAGONALISE THE MATCHING MATRIX AND FIND THE EIGENVECTOR CORRESPONDING
C  TO THE SMALLEST EIGENVALUE.
C
      IFAIL=0
      CALL DIAGVC(Y2, N, N, U, Y1)
C
C  COUNT THE NUMBER OF NEGATIVE EIGENVALUES AND IDENTIFY THE INDEX OF
C  THE SMALLEST EIGENVALUE.  COPY THE CORRESPONDING EIGENVECTOR INTO
C  PSIMCH
      NEGCNT=0
      EIGMIN=1.D30
      DO I=1,N
        IF (U(I).LE.0.D0) NEGCNT=NEGCNT+1
        IF (ABS(U(I)).GT.ABS(EIGMIN)) CYCLE
        EIGMIN=U(I)
        IMIN=I
      ENDDO
      DO I=1,N
        PSIMCH(I)=Y1((IMIN-1)*N+I)
      ENDDO
C  INCLUDE NEGCNT INSTEAD OF DOING 3RD PROPAGATION (SEPT 2012)
      NODEC=NODEC+NEGCNT
      IF (IPRINT.GE.8) WRITE(6,70) NEGCNT
  70  FORMAT('  COUNT OF NEGATIVE EIGENVALUES OF MATCHING MATRIX',
     1       ' GIVES',I6,' ADDITIONAL NODES.')
C
      IF (IPRINT.GE.9) WRITE(6,80) (I,U(I),I=1,N)
  80  FORMAT(/'  EIGENVALUES OF MATCHING MATRIX ARE:'/
     1       (2X,5(0P,I4,1P,1X,G15.7)))

C
C  REMAINING CODE IS FOR BACK-SUBSTITUTION OF WAVEFUNCTIONS
C
      IF (.NOT.WAVE) RETURN

      CALL WVPROP(RBSEG,RESEG,DRSEG,IPRSEG,NSEG)
C  NEED TWO COPIES OF PSIMCH (U, Y1 AND Y2 CAN NOW BE USED AS WORKSPACE,
C  SO ARE USED FOR RAB, A COPY OF PSIMCH, AND PSIA RESPECTIVELY))
      Y1(1:N)=PSIMCH(1:)
C
C  REVERSE PROPAGATION FROM RMATCH TO GET WAVEFUNCTION
      DO IBACK=1,2
        PSIMCH(1:N)=Y1(1:N)
        IWREC=KREC(IBACK)
        IF (IBACK.EQ.2) THEN
          JSEGB=NSEG
          JSEGE=ICHNGE+1
        ELSE
          JSEGB=ICHNGE
          JSEGE=1
        ENDIF
C
C  JPREC IS WHERE TO WRITE PSI TO, SO FOR IBACK=1 GOES FROM LARGE NUMBER
C  BACK TOWARDS 1, AND FOR IBACK=2 GOES FROM LARGE NUMBER FORWARDS TO EVEN
C  BIGGER NUMBER (WHEN IBACK=2 WRITE OUT OF FIRST RECORD IS SKIPPED OVER).
        JPREC=KREC(1)
        DO JSEG=JSEGB,JSEGE,-1
          RSTART=RBSEG(JSEG)
          RSTOP=RESEG(JSEG)
          IF (RSTART.EQ.RSTOP) THEN
            NSTEPS(JSEG)=0
            CYCLE
          ENDIF
          DR=DRSEG(JSEG)
          LFIRST=IBACK.EQ.1 .AND. JSEG.EQ.JSEGB
          IF (NSTEPS(JSEG).LE.7) THEN
            WRITE(6,*) ' *** WARNING: TOO FEW INTERVALS FOR ACCURATE'//
     1                 ' NORMALISATION OF WAVEFUNCTION IN SEGMENT ',
     2                 JSEG
            WRITE(6,*) '              BETWEEN ',RSTART,' AND ',RSTOP
          ENDIF
          CALL EFPROP(N,RSTART,RSTOP,NSTEPS(JSEG),DR,Y2,
     1                U,PSIMCH,IWREC,SUMPSI,IPRINT,JPREC,LFIRST)
          IF (IPRINT.GE.8) WRITE(6,130) RESEG(JSEG),RBSEG(JSEG),
     1                                  NSTEPS(JSEG)
  130     FORMAT(/'  WAVEFUNCTION OBTAINED BY BACK-SUBSTITUTION FROM ',
     1           F10.4,' TO ',F10.4,' IN ',I6, ' STEPS')
        ENDDO
      ENDDO

C  COLLECT THE CONTRIBUTIONS TO THE NORMALISATION CONSTANT
      IF (IPRINT.GE.6) WRITE(6,140)
 140  FORMAT(/"  NORMALISATION INTEGRAL CALCULATED BY SIMPSON'S RULE ",
     1        "FOR EACH CHANNEL")
      ANORM=0.D0
      DO I=1,N
        ANORM=ANORM+SUMPSI(I)
        IF (IPRINT.GE.8) WRITE(6,150) I,SUMPSI(I)
 150    FORMAT(I4,5X,G25.15)
      ENDDO
      IF (IPRINT.GE.6) WRITE(6,160) ANORM
 160  FORMAT(/'  TOTAL NORMALISATION INTEGRAL',5X,G18.10)
C
C  WRITE OUT WAVEFUNCTION TO IPSI IN ORDER RMIN TO RMAX
C
      NTSTPS=SUM(NSTEPS(1:NSEG))
      CALL WVSTPS(NTSTPS+1)
      DO I=1,NTSTPS+1
        READ(IPSISC,REC=I) R,PSIMCH
        IF (PSIFMT) THEN
          WRITE(IPSI,FMT=F2000) R,PSIMCH/SQRT(ANORM)
        ELSE
          WRITE(IPSI) R,PSIMCH/SQRT(ANORM)
        ENDIF
      ENDDO
      CLOSE (IPSISC)
      CLOSE (IWAVSC)
C
      RETURN
      END
